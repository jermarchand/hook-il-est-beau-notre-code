:toc:

= Conclusions

TODO : à finir par Luc et Jérôme

image::assets/Pensieve_merged_black-blueish.png[]

* toute convention non outillée sera oubliée
* activation et configuration des hooks via des fichiers déclaratifs (`.pre-commit-config.yaml` et les fichiers de configuration habituels des outils ou du projet)
* les IDE repèrent les configurations et guident l'écriture du code AVANT le commit (utile pour la détection d'antipatterns)
* pas besoin d'écrire du shell (sauf un peu pour les mono-repos, où c'est souvent inévitable)
* grande diversité de hooks natifs à pre-commit pour les problématiques transverses ou classiques (trailing-whitespace, end-of-file-fixer, check-added-large-files, double-quote-string-fixer, etc.)

* les outils de formatage de code (isort, yapf, black, etc.) doivent avoir des configurations compatibles (nombre de caractères max par ligne)
* désactiver la vérification de longueur max de lignes dans les outils de lint (pylint, ruff), les outils de formatage s'en occupent (du mieux qu'ils peuvent)

* ceinture (pré commit) et bretelles (intégration continue) sur la qualité de code
* la ceinture peut être fragile
** `pre-commit install` doit être faite sur chaque poste de développement (projet python ; commande docker équivalente pour un projet dans un autre langage)
** ou reconfiguration du chemin des hooks git (mono-repo)


* les bretelles (intégration continue) nécessitent que le projet soit `git`ifié


* les outils de qualité de code Python ont fait la démarche pour être activables via pre-commit
* mais aussi d'autres (eslint, à compléter)
